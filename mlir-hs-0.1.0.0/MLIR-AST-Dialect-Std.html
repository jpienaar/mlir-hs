<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>MLIR.AST.Dialect.Std</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">mlir-hs-0.1.0.0</span><ul class="links" id="page-menu"><li><a href="src/MLIR.AST.Dialect.Std.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">MLIR.AST.Dialect.Std</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">assert</a></li><li><a href="#g:2">atomic_rmw</a></li><li><a href="#g:3">atomic_yield</a></li><li><a href="#g:4">br</a></li><li><a href="#g:5">call_indirect</a></li><li><a href="#g:6">call</a></li><li><a href="#g:7">cond_br</a></li><li><a href="#g:8">constant</a></li><li><a href="#g:9">generic_atomic_rmw</a></li><li><a href="#g:10">rank</a></li><li><a href="#g:11">return</a></li><li><a href="#g:12">select</a></li><li><a href="#g:13">splat</a></li><li><a href="#g:14">switch</a></li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">pattern</span> <a href="#v:Branch">Branch</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST-Builder.html#t:BlockName" title="MLIR.AST.Builder">BlockName</a> -&gt; [<a href="MLIR-AST.html#t:Name" title="MLIR.AST">Name</a>] -&gt; <a href="MLIR-AST.html#t:Operation" title="MLIR.AST">Operation</a></li><li class="src short"><a href="#v:br">br</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:BlockName" title="MLIR.AST.Builder">BlockName</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a></li><li class="src short"><a href="#v:cond_br">cond_br</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:BlockName" title="MLIR.AST.Builder">BlockName</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; <a href="MLIR-AST-Builder.html#t:BlockName" title="MLIR.AST.Builder">BlockName</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a></li><li class="src short"><span class="keyword">pattern</span> <a href="#v:Assert">Assert</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; operand -&gt; <a href="../bytestring-0.10.12.0/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:assert">assert</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="../bytestring-0.10.12.0/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m ()</li><li class="src short"><span class="keyword">pattern</span> <a href="#v:AtomicYield">AtomicYield</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:atomic_yield">atomic_yield</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a></li><li class="src short"><a href="#v:call_indirect">call_indirect</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a>] -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><span class="keyword">pattern</span> <a href="#v:Constant">Constant</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST.html#t:Attribute" title="MLIR.AST">Attribute</a> -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:constant">constant</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST.html#t:Attribute" title="MLIR.AST">Attribute</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><a href="#v:generic_atomic_rmw">generic_atomic_rmw</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><span class="keyword">pattern</span> <a href="#v:Rank">Rank</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:rank">rank</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><span class="keyword">pattern</span> <a href="#v:Return">Return</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; [operand] -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:return">return</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a></li><li class="src short"><span class="keyword">pattern</span> <a href="#v:Select">Select</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; operand -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:select">select</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><span class="keyword">pattern</span> <a href="#v:Splat">Splat</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:splat">splat</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Branch" class="def">Branch</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST-Builder.html#t:BlockName" title="MLIR.AST.Builder">BlockName</a> -&gt; [<a href="MLIR-AST.html#t:Name" title="MLIR.AST">Name</a>] -&gt; <a href="MLIR-AST.html#t:Operation" title="MLIR.AST">Operation</a> <a href="src/MLIR.AST.Dialect.Std.html#Branch" class="link">Source</a> <a href="#v:Branch" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:br" class="def">br</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:BlockName" title="MLIR.AST.Builder">BlockName</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a> <a href="src/MLIR.AST.Dialect.Std.html#br" class="link">Source</a> <a href="#v:br" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:cond_br" class="def">cond_br</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:BlockName" title="MLIR.AST.Builder">BlockName</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; <a href="MLIR-AST-Builder.html#t:BlockName" title="MLIR.AST.Builder">BlockName</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a> <a href="src/MLIR.AST.Dialect.Std.html#cond_br" class="link">Source</a> <a href="#v:cond_br" class="selflink">#</a></p></div><a href="#g:1" id="g:1"><h1>assert</h1></a><div class="doc"><p>Assert operation with single boolean operand and an error message attribute.
 If the argument is <code>true</code> this operation has no effect. Otherwise, the
 program execution will abort. The provided error message may be used by a
 runtime to propagate the error to the user.</p><p>Example:</p><pre>assert %b, &quot;Expected ... to be true&quot;
</pre></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Assert" class="def">Assert</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; operand -&gt; <a href="../bytestring-0.10.12.0/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Std.html#Assert" class="link">Source</a> <a href="#v:Assert" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>std.assert</code>.</p></div></div><div class="top"><p class="src"><a id="v:assert" class="def">assert</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="../bytestring-0.10.12.0/Data-ByteString.html#t:ByteString" title="Data.ByteString">ByteString</a> -&gt; m () <a href="src/MLIR.AST.Dialect.Generated.Std.html#assert" class="link">Source</a> <a href="#v:assert" class="selflink">#</a></p><div class="doc"><p>A builder for <code>std.assert</code>.</p></div></div><a href="#g:2" id="g:2"><h1>atomic_rmw</h1></a><div class="doc"><p>The <code>atomic_rmw</code> operation provides a way to perform a read-modify-write
 sequence that is free from data races. The kind enumeration specifies the
 modification to perform. The value operand represents the new value to be
 applied during the modification. The memref operand represents the buffer
 that the read and write will be performed against, as accessed by the
 specified indices. The arity of the indices is the rank of the memref. The
 result represents the latest value that was stored.</p><p>Example:</p><pre>%x = atomic_rmw &quot;addf&quot; %value, %I[%i] : (f32, memref&lt;10xf32&gt;) -&gt; f32
</pre></div><a href="#g:3" id="g:3"><h1>atomic_yield</h1></a><div class="doc"><p>&quot;atomic_yield&quot; yields an SSA value from a GenericAtomicRMWOp region.</p></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:AtomicYield" class="def">AtomicYield</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Std.html#AtomicYield" class="link">Source</a> <a href="#v:AtomicYield" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>std.atomic_yield</code>.</p></div></div><div class="top"><p class="src"><a id="v:atomic_yield" class="def">atomic_yield</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a> <a href="src/MLIR.AST.Dialect.Generated.Std.html#atomic_yield" class="link">Source</a> <a href="#v:atomic_yield" class="selflink">#</a></p><div class="doc"><p>A builder for <code>std.atomic_yield</code>.</p></div></div><a href="#g:4" id="g:4"><h1>br</h1></a><div class="doc"><p>The <code>br</code> operation represents a branch operation in a function.
 The operation takes variable number of operands and produces no results.
 The operand number and types for each successor must match the arguments of
 the block successor.</p><p>Example:</p><pre>^bb2:
  %2 = call @someFn()
  br ^bb3(%2 : tensor&lt;*xf32&gt;)
^bb3(%3: tensor&lt;*xf32&gt;):
</pre></div><a href="#g:5" id="g:5"><h1>call_indirect</h1></a><div class="doc"><p>The <code>call_indirect</code> operation represents an indirect call to a value of
 function type. Functions are first class types in MLIR, and may be passed as
 arguments and merged together with block arguments. The operands and result
 types of the call must match the specified function type.</p><p>Function values can be created with the
 <code>constant</code> operation.</p><p>Example:</p><pre>%31 = call_indirect %15(%0, %1)
        : (tensor&lt;16xf32&gt;, tensor&lt;16xf32&gt;) -&gt; tensor&lt;16xf32&gt;
</pre></div><div class="top"><p class="src"><a id="v:call_indirect" class="def">call_indirect</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a>] -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Std.html#call_indirect" class="link">Source</a> <a href="#v:call_indirect" class="selflink">#</a></p><div class="doc"><p>A builder for <code>std.call_indirect</code>.</p></div></div><a href="#g:6" id="g:6"><h1>call</h1></a><div class="doc"><p>The <code>call</code> operation represents a direct call to a function that is within
 the same symbol scope as the call. The operands and result types of the
 call must match the specified function type. The callee is encoded as a
 symbol reference attribute named &quot;callee&quot;.</p><p>Example:</p><pre>%2 = call @my_add(%0, %1) : (f32, f32) -&gt; f32
</pre></div><a href="#g:7" id="g:7"><h1>cond_br</h1></a><div class="doc"><p>The <code>cond_br</code> terminator operation represents a conditional branch on a
 boolean (1-bit integer) value. If the bit is set, then the first destination
 is jumped to; if it is false, the second destination is chosen. The count
 and types of operands must align with the arguments in the corresponding
 target blocks.</p><p>The MLIR conditional branch operation is not allowed to target the entry
 block for a region. The two destinations of the conditional branch operation
 are allowed to be the same.</p><p>The following example illustrates a function with a conditional branch
 operation that targets the same block.</p><p>Example:</p><pre>func @select(%a: i32, %b: i32, %flag: i1) -&gt; i32 {
  // Both targets are the same, operands differ
  cond_br %flag, ^bb1(%a : i32), ^bb1(%b : i32)

^bb1(%x : i32) :
  return %x : i32
}
</pre></div><a href="#g:8" id="g:8"><h1>constant</h1></a><div class="doc"><p>Syntax:</p><pre>operation ::= ssa-id <code>=</code> <code>std.constant</code> attribute-value <code>:</code> type
</pre><p>The <code>constant</code> operation produces an SSA value equal to some constant
 specified by an attribute. This is the way that MLIR uses to form simple
 integer and floating point constants, as well as more exotic things like
 references to functions and tensor/vector constants.</p><p>Example:</p><pre>// Complex constant
%1 = constant [1.0 : f32, 1.0 : f32] : complex&lt;f32&gt;

// Reference to function @myfn.
%2 = constant @myfn : (tensor&lt;16xf32&gt;, f32) -&gt; tensor&lt;16xf32&gt;

// Equivalent generic forms
%1 = &quot;std.constant&quot;() {value = [1.0 : f32, 1.0 : f32] : complex&lt;f32&gt;}
   : () -&gt; complex&lt;f32&gt;
%2 = &quot;std.constant&quot;() {value = @myfn}
   : () -&gt; ((tensor&lt;16xf32&gt;, f32) -&gt; tensor&lt;16xf32&gt;)
</pre><p>MLIR does not allow direct references to functions in SSA operands because
 the compiler is multithreaded, and disallowing SSA values to directly
 reference a function simplifies this
 (rationale.</p></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Constant" class="def">Constant</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST.html#t:Attribute" title="MLIR.AST">Attribute</a> -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Std.html#Constant" class="link">Source</a> <a href="#v:Constant" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>std.constant</code>.</p></div></div><div class="top"><p class="src"><a id="v:constant" class="def">constant</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST.html#t:Attribute" title="MLIR.AST">Attribute</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Std.html#constant" class="link">Source</a> <a href="#v:constant" class="selflink">#</a></p><div class="doc"><p>A builder for <code>std.constant</code>.</p></div></div><a href="#g:9" id="g:9"><h1>generic_atomic_rmw</h1></a><div class="doc"><p>The <code>generic_atomic_rmw</code> operation provides a way to perform a read-modify-write
 sequence that is free from data races. The memref operand represents the
 buffer that the read and write will be performed against, as accessed by
 the specified indices. The arity of the indices is the rank of the memref.
 The result represents the latest value that was stored. The region contains
 the code for the modification itself. The entry block has a single argument
 that represents the value stored in <code>memref[indices]</code> before the write is
 performed. No side-effecting ops are allowed in the body of
 <code>GenericAtomicRMWOp</code>.</p><p>Example:</p><pre>%x = generic_atomic_rmw %I[%i] : memref&lt;10xf32&gt; {
  ^bb0(%current_value : f32):
    %c1 = arith.constant 1.0 : f32
    %inc = arith.addf %c1, %current_value : f32
    atomic_yield %inc : f32
}
</pre></div><div class="top"><p class="src"><a id="v:generic_atomic_rmw" class="def">generic_atomic_rmw</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Std.html#generic_atomic_rmw" class="link">Source</a> <a href="#v:generic_atomic_rmw" class="selflink">#</a></p><div class="doc"><p>A builder for <code>std.generic_atomic_rmw</code>.</p></div></div><a href="#g:10" id="g:10"><h1>rank</h1></a><div class="doc"><p>The <code>rank</code> operation takes a memref/tensor operand and returns its rank.</p><p>Example:</p><pre>%1 = rank %arg0 : tensor&lt;*xf32&gt;
%2 = rank %arg1 : memref&lt;*xf32&gt;
</pre></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Rank" class="def">Rank</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Std.html#Rank" class="link">Source</a> <a href="#v:Rank" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>std.rank</code>.</p></div></div><div class="top"><p class="src"><a id="v:rank" class="def">rank</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Std.html#rank" class="link">Source</a> <a href="#v:rank" class="selflink">#</a></p><div class="doc"><p>A builder for <code>std.rank</code>.</p></div></div><a href="#g:11" id="g:11"><h1>return</h1></a><div class="doc"><p>The <code>return</code> operation represents a return operation within a function.
 The operation takes variable number of operands and produces no results.
 The operand number and types must match the signature of the function
 that contains the operation.</p><p>Example:</p><pre>func @foo() : (i32, f8) {
  ...
  return %0, %1 : i32, f8
}
</pre></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Return" class="def">Return</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; [operand] -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Std.html#Return" class="link">Source</a> <a href="#v:Return" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>std.return</code>.</p></div></div><div class="top"><p class="src"><a id="v:return" class="def">return</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a> <a href="src/MLIR.AST.Dialect.Generated.Std.html#return" class="link">Source</a> <a href="#v:return" class="selflink">#</a></p><div class="doc"><p>A builder for <code>std.return</code>.</p></div></div><a href="#g:12" id="g:12"><h1>select</h1></a><div class="doc"><p>The <code>select</code> operation chooses one value based on a binary condition
 supplied as its first operand. If the value of the first operand is <code>1</code>,
 the second operand is chosen, otherwise the third operand is chosen.
 The second and the third operand must have the same type.</p><p>The operation applies to vectors and tensors elementwise given the _shape_
 of all operands is identical. The choice is made for each element
 individually based on the value at the same position as the element in the
 condition operand. If an i1 is provided as the condition, the entire vector
 or tensor is chosen.</p><p>The <code>select</code> operation combined with <code>cmpi</code> can be used
 to implement <code>min</code> and <code>max</code> with signed or unsigned comparison semantics.</p><p>Example:</p><pre>// Custom form of scalar selection.
%x = select %cond, %true, %false : i32

// Generic form of the same operation.
%x = &quot;std.select&quot;(%cond, %true, %false) : (i1, i32, i32) -&gt; i32

// Element-wise vector selection.
%vx = std.select %vcond, %vtrue, %vfalse : vector&lt;42xi1&gt;, vector&lt;42xf32&gt;

// Full vector selection.
%vx = std.select %cond, %vtrue, %vfalse : vector&lt;42xf32&gt;
</pre></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Select" class="def">Select</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; operand -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Std.html#Select" class="link">Source</a> <a href="#v:Select" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>std.select</code>.</p></div></div><div class="top"><p class="src"><a id="v:select" class="def">select</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Std.html#select" class="link">Source</a> <a href="#v:select" class="selflink">#</a></p><div class="doc"><p>A builder for <code>std.select</code>.</p></div></div><a href="#g:13" id="g:13"><h1>splat</h1></a><div class="doc"><p>Broadcast the operand to all elements of the result vector or tensor. The
 operand has to be of integer<em>index</em>float type. When the result is a tensor,
 it has to be statically shaped.</p><p>Example:</p><pre>%s = load %A[%i] : memref&lt;128xf32&gt;
%v = splat %s : vector&lt;4xf32&gt;
%t = splat %s : tensor&lt;8x16xi32&gt;
</pre><p>TODO: This operation is easy to extend to broadcast to dynamically shaped
 tensors in the same way dynamically shaped memrefs are handled.</p><pre>// Broadcasts %s to a 2-d dynamically shaped tensor, with %m, %n binding
// to the sizes of the two dynamic dimensions.
%m = &quot;foo&quot;() : () -&gt; (index)
%n = &quot;bar&quot;() : () -&gt; (index)
%t = splat %s [%m, %n] : tensor&lt;?x?xi32&gt;
</pre></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Splat" class="def">Splat</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Std.html#Splat" class="link">Source</a> <a href="#v:Splat" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>std.splat</code>.</p></div></div><div class="top"><p class="src"><a id="v:splat" class="def">splat</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Std.html#splat" class="link">Source</a> <a href="#v:splat" class="selflink">#</a></p><div class="doc"><p>A builder for <code>std.splat</code>.</p></div></div><a href="#g:14" id="g:14"><h1>switch</h1></a><div class="doc"><p>The <code>switch</code> terminator operation represents a switch on a signless integer
 value. If the flag matches one of the specified cases, then the
 corresponding destination is jumped to. If the flag does not match any of
 the cases, the default destination is jumped to. The count and types of
 operands must align with the arguments in the corresponding target blocks.</p><p>Example:</p><pre>switch %flag : i32, [
  default: ^bb1(%a : i32),
  42: ^bb1(%b : i32),
  43: ^bb3(%c : i32)
]
</pre></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.0</p></div></body></html>